defaults:
  deckName: Staging
  modelName: CodingProblems
  tags:
  - Code
  - Algorithms
  - Brainstorms

  fields:
    Python: "**To-do: Python.**"
    Java: "**To-do: Java.**"
    C++: "**To-do: C++.**"
    Back: "**To-do: Back.**"

  markdownTabLength: 4


notes:


- fields:
    Front: |
      Write selection sort.
    Python: |
      ```{python }
      #
      def selection_sort(data):
        n = len(data)
        for i in range(n):
          minimum = i
          for j in range(i+1,n):
            if data[j] < data[minimum]:
              minimum = j
          if i < minimum:
            data[i], data[minimum] = data[minimum], data[i]
        return data

      data = [1, 9, 2, 8, 3, 7, 2, 7, 8, 6]
      print(selection_sort(data))
      ```
    Java: |
      ```{java }
      import java.util.ArrayList;
      import java.util.Collections;
      import java.util.List;

      public class Sorts {
        public static List<Integer> sort(List<Integer> l){
          int n = l.size();
          for(int i = 0; i < n; i++){
            int min_idx = i;
            for(int j = i + 1; j < n; j++){
              if(l.get(j) < l.get(min_idx)){
                min_idx = j;
              }
            }
            if(i < min_idx){
              Collections.swap(l, i, min_idx);
            }
          }
          return l;
        }

        public static void print_array(List<Integer> s){
          for(int x: s.subList(0, s.size()-1)){
            System.out.printf("%d, ", x);
          }
          System.out.printf("%d%n", s.get(s.size()-1));
        }

        public static void main(String[] args){
          int[] data = {1, 9, 2, 8, 3, 7, 2, 7, 8, 6};
          ArrayList<Integer> d = new ArrayList<>();
          for(int x: data){ d.add(x); }
          print_array(sort(d));
        }
      }
      // String[] args;
      // Sorts.main(args);
      ```


- fields:
    Front: |
      Write insertion sort.
    Python: |
      ```{python }
      #
      def insertion_sort(data):
        for i in range(len(data)):
          for j in reversed(range(i)):
            if data[j] <= data[j+1]:
              break
            data[j+1], data[j] = data[j], data[j+1]
        return data

      print(insertion_sort([1, 9, 2, 8, 3, 7, 2, 7, 8, 6]))
      ```
    Java: |
      ```{java }
      import java.util.ArrayList;
      import java.util.Collections;
      import java.util.List;

      public class Sorts {
        public static List<Integer> sort(List<Integer> l){
          int n = l.size();
          for(int i = 0; i < n; i++){
            for(int j = i; 0 < j; j--){
              if(l.get(j-1) <= l.get(j)){
                break;
              }
              Collections.swap(l, j-1, j);
            }
          }
          return l;
        }

        public static void print_array(List<Integer> s){
          for(int x: s.subList(0, s.size()-1)){
            System.out.printf("%d, ", x);
          }
          System.out.printf("%d%n", s.get(s.size()-1));
        }

        public static void main(String[] args){
          int[] data = {1, 9, 2, 8, 3, 7, 2, 7, 8, 6};
          ArrayList<Integer> d = new ArrayList<>();
          for(int x: data){ d.add(x); }
          print_array(sort(d));
        }
      }
      // String[] args;
      // Sorts.main(args);
      ```


- fields:
    Front: |
      Write heapsort.
    Python: |
      ```{python }
      #
      def heapify(data, i, heap_size):
        while True:
          l = 2*i+1

          if heap_size <= l:
            # There are no more children.
            return

          r = l + 1
          if heap_size <= r:
            # Only left child, which has no children.
            if data[i] < data[l]:
              # Sift.
              data[i], data[l] = data[l], data[i]
            return

          c = l
          # Choose larger child.
          if data[c] < data[r]:
            c = r
          if data[c] <= data[i]:
            # Element is in proper position.
            break
          # Sift.
          data[i], data[c] = data[c], data[i]
          # On to next possible sift.
          i = c

      def heapsort(data):
        n = len(data)
        # Heapify.
        for i in reversed(range(n)):
          heapify(data, i, n)
        # Extract sorted elements to rear of array.
        for i in reversed(range(n)):
          data[0], data[i] = data[i], data[0]
          heapify(data, 0, i)
        return data

      data = [1, 9, 2, 8, 3, 7, 2, 7, 8, 6]
      expected = [1, 2, 2, 3, 6, 7, 7, 8, 8, 9]
      result = heapsort(data)
      print(result)
      print(result == expected)
      ```
