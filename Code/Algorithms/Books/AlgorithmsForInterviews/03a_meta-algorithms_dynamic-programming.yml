deckName: Staging
modelName: CodingProblems
tags:
- Code
- Algorithms
- Books
- AlgorithmsForInterviews
- 03-MetaAlgorithms
- 03a-DynamicProgramming

markdownTabLength: 4

notes:


- Front: |
    ## 03.01: Longest nondecreasing subsequence

    In genomics, given two gene sequences, we try to find if parts of one gene are the same as the other. Thus it is important to find the longest common subsequence of the two sequences. One way to solve this problem is to construct a new sequence where for each literal in one sequence, we insert its position into the other sequence and then find the longest nondecreasing subsequence of this new subsequence. For example, if the two sequences are \\(\langle 1, 3, 5, 2, 7 \rangle\\) and \\(\langle 1, 2, 3, 5, 7 \rangle\\), we would construct a new sequence where for each position in the first sequence, we would list its position in the second sequence like so, \\(\langle 1, 3, 4, 2, 5\rangle\\). Then we find the 1ongest nondecreasing sequence which is \\(\langle 1, 3, 4, 5 \rangle\\). Now, if we use the numbers of the new sequence as indices into the second sequence, we get \\(\langle 1, 3, 5, 7 \rangle\\) which is our longest common subsequence.

    Given an array of integers \\(A\\) of length \\(n\\), find the longest sequence \\(\langle i_1, \ldots, i_k \rangle\\) such that \\(i_j < i_{j十1}\\) and \\(A[i_j] \leq A[i_{j+1}\\) for any \\(j \in [1 , k 一 1]\\).

    --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 31.

  Python: |
    **To-do: Python.**

  Java: |
    **To-do: Java.**

  C++: |
    **To-do: C++.**


- Front: |
    ## 03.02: Frog crossing

    DP is often used to compute a plan for performing a task that consists of a series of actions in an optimum way. Here is an example with an interesting twist.

    There is a river that is \\(n\\) meters wide. At every meter from the edge, there may or may not be a stone. A frog needs to cross the river. However the frog has the limitation that if it has just jumped \\(x\\) meters, then its next jump must be between \\(x-1\\) and \\(x+1\\) meters, inclusive. Assume the first jump can be of only 1 meter. Given the position of the stones, how would you determine whether the frog can make it to the other end or not? Analyze the runtime of your algorithm.

    --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 31-2.

  Python: |
    **To-do: Python.**

  Java: |
    **To-do: Java.**

  C++: |
    **To-do: C++.**
