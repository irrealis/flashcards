defaults:
  deckName: Staging
  modelName: CodingProblems
  tags:
  - Code
  - Algorithms
  - Books
  - AlgorithmsForInterviews
  - 05-AlgorithmsOnStrings

  fields:
    Python: "**To-do: Python.**"
    Java: "**To-do: Java.**"
    C++: "**To-do: C++.**"

  markdownTabLength: 4


notes:

- fields:
    Front: |
      ## 05.01: Find all occurrences of a substring

      A good string-search algorithm is fundamental to the performance of many applications, and there are several elegant algorithms proposed for it, each with its own tradeoffs. As a result, there is no one perfect answer to it. If someone asks you this question in an interview, the best way to approach this problem would be to work through one good algorithm in detail and discuss the breadth of other algorithms for solving this problem.

      Given two strings \\(s\\) (search string) and \\(T\\) (text), find all occurrences of \\(s\\) in \\(T\\).

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 52.


- fields:
    Front: |
      ## 05.02: String matching with unique characters

      Suppose we are looking for a search string \\(S\\) in another string \\(T\\). A naïve algorithm would try to match all the characters in \\(S\\) to characters in \\(T\\) at each offset. The worst-case complexity of the naïve algorithm is \\(\Theta(|S| \cdot |T|)\\) --- consider the case where \\(S\\) is \\(2n\\) zeros, and \\(T\\) is \\(n-1\\) zeros followed by a one.

      The worst-case behavior for the naïve algorithm requires many duplicated characters. Suppose no character occurs more than once in the search string. Devise an algorithm to efficiently search for all occurrences of the search string in the text string.

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 53.


- fields:
    Front: |
      ## 05.03: Rotate a string

      Let \\(A\\) be a string of length \\(n\\). If we have enough memory to make a copy of \\(A\\), rotating \\(A\\) by \\(i\\) positions is trivial; we just compute \\(B[j] = A[(i + j) \mod n]\\). If we are given only a constant amount of additional memory \\(c\\), we can rotate the string by \\(c\\) positions a total of \\(k = \lceil\frac{n}{c}\rceil\\) times, but this increases the time complexity to \\(\Theta(n \cdot k)\\).

      Design a \\(\Theta(n)\\) algorithm for rotating a string of \\(n\\) letters to the left by \\(i\\) positions. You are allowed only a constant number of bytes of additional storage.

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 53.
