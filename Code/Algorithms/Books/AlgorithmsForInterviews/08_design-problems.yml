defaults:
  deckName: Staging
  modelName: BasicMathJax
  tags:
  - Code
  - Algorithms
  - Books
  - AlgorithmsForInterviews
  - 08-DesignProblems

  fields:
    Back: "**To-do: Back.**"

  markdownTabLength: 4


notes:

- fields:
    Front: |
      ## 08.01: Mosaic

      One popular form of computer art is photomosaics where you are given a collection of images called "tiles". Then, given a target image, you want to build another image which closely approximates the target image but is actually built by juxtaposing the tiles. Here the quality of approximation is mostly defined by human perception. It is often the case that with a given set of tiles, a user may want to build several mosaics.

      How would you design a software that produces high-quality mosaics with minimal compute time?

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 67.


- fields:
    Front: |
      ## 08.02: Search engine

      Modern keyword-based search engines maintain a collection of several billion documents. One of the key computations performed by a search engine is to retrieve all the documents that contain the keywords contained in a given query. This is a nontrivial task because it must be done within few tens of milliseconds.

      In this problem, we consider a smaller version of the problem where the collection of documents can fit within the RAM of a single computer.

      Given a million documents with an average size of ten kilobytes, design a program that can efficiently return the subset of documents containing a given set of words.

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 68.


- fields:
    Front: |
      ## 08.03: IP forwarding

      There are many applications where instead of an exact match of strings, we are looking for a prefix match, i.e., given a set of strings and a search string, we want to find a string from the set that is a prefix of the search string. One application of this is Internet Protocol (IP) route lookup problem. When an IP packet arrives at a router, the router looks up the next hop for the packet by searching the destination IP address of the packet in its routing table. The routing table is specified as a set of prefixes on the IP address, and the router is supposed to identify the longest matching prefix. If this task is to be performed only once, it is impossible to do better than testing each prefix. However, an Internet core router needs to lookup millions of destination addresses on the set of prefixes every second. Hence it can be advantageous to do some precomputation.

      You are given a large set of strings \\(S\\) in advance. Given a query string \\(Q\\), how would you design a system that can identify the longest string \\(p \in S\\) that is a prefix of \\(Q\\)?

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 68.


- fields:
    Front: |
      ## 08.04: Spell checker

      Edit distance may not be the right distance function when performing spelling correction --- it does not take into account the commonly misspelled words or the proximity of letters on a keyboard.

      How would you build a spelling correction system?

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 68.


- fields:
    Front: |
      ## 08.05: Stemming

      When a user submits the query "computation" to a search engine, it is quite possible he might also be interested in documents containing the words "computers", "compute", and "computing". If you have several keywords in a query, it becomes difficult to search for all combinations of all variants of the words in the query.

      One way to solve this problem is to reduce all variants of a given word to one common root, both in the query string and in the documents. This process is called stemming. An example of stemming would be \\(\\{computers,computer,compute\\}\mapsto comput\\). It is almost impossible to succinctly capture all possible variants of all words in the English language, but a few simple rules can get us a majority of the cases.

      Design a stemming algorithm that runs fast and does a reasonable job.

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 69.


- fields:
    Front: |
      ## 08.06: Distributed throttling

      Let's say you have \\(N\\) machines crawling the world wide web such that the responsibility for a given URL is assigned to the crawler with id equal to `Hash(URL)`\\(\mod N\\). Downloading a page takes away bandwidth from the server hosting it. Therefore you want to ensure that in any given minute, your crawlers never request more than \\(B\\) bytes from any host.

      How would you implement crawling under such a constraint?

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 69.
