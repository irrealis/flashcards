defaults:
  deckName: Staging
  modelName: CodingProblems
  tags:
  - Code
  - Algorithms
  - Books
  - AlgorithmsForInterviews
  - 07-ParallelComputing

  fields:
    Python: "**To-do: Python.**"
    Java: "**To-do: Java.**"
    C++: "**To-do: C++.**"
    Back: "**To-do: Back.**"

  markdownTabLength: 4


notes:

- fields:
    Front: |
      ## 07.01: Servlet with caching

      Design a servlet which implements an online spell correction suggester. Specifically, it takes as input a string \\(s\\) and computes an array of entries in its dictionary which are closest to the string using the edit distance specified in Problem 5.8. Since computing the edit distances from \\(s\\) to each entry in the dictionary is time-consuming, you should implementa a caching strategy. Specifically, cache the most recently computed result.

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 63.


- modelName: BasicMathJax
  fields:
    Front: |
      ## 07.02: Thread pools

      The following class, `SimpleWebServer`, implements part of a simple HTTP server:

      ```{java }
      public class SimpleWebServer {
        final static int PORT = 8080;
        public static void main(String [] args)
          throws IOException
        {
          ServerSocket serversock = new ServerSocket(PORT);
          for (;;) {
            Socket sock = serversock.accept();
            ProcessReq(sock);
          }
        }
      }
      ```

      Suppose you find that `SimpleWebServer` has poor performance because `ProcessReq` frequently blocks on IO. What steps could you take to improve `SimpleWebServer`'s performance?

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 64.


- fields:
    Front: |
      ## 07.03: Asynchronous callbacks

      It is common in a distributed computing environment for the responses to not return in the same order as the requests were made. One way to handle this is through an "asynchronous callback" --- a method to be invoked on response.

      Implement a `Requestor` class. The class has to implement a `Dispatch` method which takes a `Requestor` object. The `Requestor` obect includes a `request` string, a `ProcessResponse (string response)` method, and an `Execute` method that takes a string and returns a string.

      `Dispatch` is to create a new thread which invokes `Execute` on `request`. When `Execute` returns, `Dispatch` invokes the `ProcessResponse` method on the response.

      The `Execute` method may take an indeterminate amount of time to return; it may never return. You need to have a time-out mechanism for this: assume the `Requestor` objects have an `Error` method that you can invoke.

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 64.


- fields:
    Front: |
      ## 07.04: Timer

      Consider a web-based calendar in which the server hosting the calendar has to perform a task when the next calendar event takes place. (The task could be sending an email or an SMS.) Your job is to design a facility that manages the execution of such tasks.

      Develop a `Timer` class that manages the execution of deferred tasks. Specifically, at creation, the constructor of `Timer` is passed an object which includes a `Run` method and a `name` field (which is a string). The `Timer` class must support:

      1. starting a thread at a given time in the future; the thread is identified by name; and
      2. canceling a thread with a given name (you can ignore the request if the thread has already started).

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 64-5.


- fields:
    Front: |
      ## 07.05: Readers-writers with read preference

      Consider an object \\(s\\) that is read from and written to by many threads. (For example, \\(s\\) could be a cache.) You need to ensure that no thread may access \\(s\\) for reading or writing while another thread is writing to \\(s\\). (Two or more readers may access \\(s\\) at the same time.)

      One way to achieve this is by protecting \\(s\\) with a mutex that ensures that no thread can access \\(s\\) at the same time as another writer. However, this solution is suboptimal because it is possible that a reader \\(R_1\\) has locked \\(s\\), and another reader \\(R_2\\) wants to access \\(s\\). There is no need to make \\(R_2\\) wait until \\(R_1\\) is done reading; instead, \\(R_2\\) should start reading right away.

      This motivates the first readers-writers problem: protect \\(s\\) with the added constraint that no reader is to be kept waiting if \\(s\\) is currently opened for reading.

      Implement a synchronization mechanism for the first readers-writers problem.

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 65.


- fields:
    Front: |
      ## 07.06: Readers-writers with write preference

      Suppose we have an object \\(s\\). In the first readers-writers problem, a reader \\(R_1\\) may have the lock; if a writer \\(W\\) is waiting for the lock and then a reader \\(R_2\\) requests access, \\(R_2\\) will be given priority over \\(W\\). If this happens often enough, \\(W\\) will starve. Instead, suppose we want \\(W\\) to start as soon as possible.

      This motivates the second readers-writers problem: protect \\(s\\) with "writer-preference", i.e., no writer, once added to the queue, is to be kept waiting longer than absolutely necessary.

      Implement a synchronization mechanism for the second readers-writers problem.

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 65.


- fields:
    Front: |
      ## 07.07: Readers-writers with fairness

      The specifications to both the first and second readers-writers problems can lead to starvation --- the first may starve writers, and the second may starve readers. The third readers-writers problem adds the constraint that no thread shall be allowed to starve --- the operation of obtaining a lock on \\(s\\) always terminates in a bounded amount of time.

      Implement a synchronization mechanism for the third readers-writers problem. It is acceptable (indeed necessary) that in this solution, both readers and writers have to wait longer than absolutely necessary. (Readers may wait even if \\(s\\) is opened for read, and writers may wait even if no one else has a lock on \\(s\\).)

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 65-6.
