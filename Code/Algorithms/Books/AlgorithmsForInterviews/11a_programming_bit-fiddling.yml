defaults:
  deckName: Staging
  modelName: CodingProblems
  tags:
  - Code
  - Algorithms
  - Books
  - AlgorithmsForInterviews
  - 11-Programming
  - 11a-BitFiddling

  fields:
    Python: "**To-do: Python.**"
    Java: "**To-do: Java.**"
    C++: "**To-do: C++.**"
    Back: "**To-do: Back.**"

  markdownTabLength: 4


notes:


- fields:
    Front: |
      ## 11.01: Computing the parity of a long

      The parity of a sequence of bits is 1 if the number of ones in the sequence is odd; otherwise, it is 0. By keeping the parity of every word of data, you can check for single-bit errors in storage or transmission. It is fairly straightforward to write a code that computes the parity of a long.

      How would you compute parity if you had to perform the computation for a very large number of longs?

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 89.


- fields:
    Front: |
      ## 11.02: Reversing the bits in a long

      There are several variants of the parity problem posed above, e.g., computing the number of bits set to 1 in a long. Here is a bit-fiddling problem that is concerned with restructuring:

      Write a function which takes a long \\(x\\) and returns a long that has the bits of \\(x\\) reversed.

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 89.
