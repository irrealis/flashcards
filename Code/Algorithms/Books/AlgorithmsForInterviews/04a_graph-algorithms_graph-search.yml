defaults:
  deckName: Staging
  modelName: CodingProblems
  tags:
  - Code
  - Algorithms
  - Books
  - AlgorithmsForInterviews
  - 04-AlgorithmsOnGraphs
  - 04a-GraphSearch

  fields:
    Python: "**To-do: Python.**"
    Java: "**To-do: Java.**"
    C++: "**To-do: C++.**"

  markdownTabLength: 4


notes:

- fields:
    Front: |
      ## 04.01: Searching a maze

      It is natural to apply graph models and algorithms to spatial problems. Consider a black and white digitized image of a maze --- white pixels represent open areas and black pixels are walls. There are two special pixels: one is designated the entrance and the other is the exit.

      Given a two-dimensional matrix of black and white entries representing a maze with designated entrance and exit points, find a path from the entrance to the exit, if one exists.

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 42-3.


- fields:
    Front: |
      ## 04.02: Order nodes in a binary tree by depth

      There are various traversals that can be performed on a tree: in-order, pre-order, and post-order are three natural examples.

      How would you efficiently return an array \\(A[0 \ldots h]\\), where \\(h\\) is the height of the tree and \\(A[i]\\) is the head of a linked list of all the nodes in the tree that are at height \\(i\\)?

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 43.


- fields:
    Front: |
      ## 04.03: Connectedness

      A connected graph is one for which, given any vertices \\(u\\) and \\(v\\), there exists a path from \\(u\\) to \\(v\\). The notion of connectedness holds for both directed and undirected graphs --- for undirected graphs, we sometimes simply say there exists a path between \\(u\\) and \\(v\\).

      Intuitively, some graphs are more connected than others --- e.g., a clique is more connected than a tree. To be more quantitative, we could refer to a graph as being \\(2\forall\\)-connected if it remains connected even if any single edge is removed. A graph is \\(2\exists\\)-connected if there exists an edge whose removal leaves the graph connected.

      One application of this idea is in fault tolerance for data networks. Suppose you are given a set of datacenters connected through a set of dedicated point-to-point links. You want to be able to reach from any datacenter to any other datacenter through a combination of these dedicated links. Sometimes one of these links can become temporarily out of service and you want to ensure that your network can sustain up to one faulty link. How can you verify this?

      Let \\(G = (V , E)\\) be a connected undirected graph. How would you efficiently check if \\(G\\) is \\(2\exists\\)-connected? Can you make you algorithm run in \\(O(|V|)\\) time? How would you check if \\(G\\) is \\(2\forall\\)-connected?

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 43.


- fields:
    Front: |
      ## 04.04: PCB wiring

      Consider a collection of \\(p\\) electrical pins. For each pair of pins, there may or may not be a wire joining them. There are \\(w\\) pairs of pins with a wire joining them.

      Give an \\(O(p + w)\\) time algorithm that determines if it is possible to place some of the pins on the left half of a PCB and the rest of the right half such that each wire is between a pin on the left and a pin on the right. Your algorithm should return a placement, should one exist.

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 43.


- fields:
    Front: |
      ## 04.05: Extended contacts

      You are given a social network. Specifically, it consists of a set of individuals and for each individual, a list of his contacts. The contact relationship need not be symmetric --- \\(A\\) may be a contact of \\(B\\) but \\(B\\) may not be a contact of \\(A\\).) Let's define \\(C\\) to be an extended contact of \\(A\\) if he is either a contact of \\(A\\) or a contact of an extended contact of \\(A\\).

      Devise an efficient algorithm which takes a social network and computes for each individual his extended contacts.

      --- Aziz and Prakash; _Algorithms for Interviews_; version 1.0.0 (September 1, 2010); p 44.
